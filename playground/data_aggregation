from semanticscholar import SemanticScholar
sch = SemanticScholar(timeout=30)

# retrieve all papers connected with the seed papers
# paper_limit for development, R: add iteration approach to remain unbiased
# returns: dictionary of all paper objects, dictionary of paper citations 
#  
def append_child_and_parents(paper_objects, paper_hierarchies, paper_lookup, paper_limit, limit_reached):

#R: for n in range(iterations):
    for p in list(paper_objects.values()):

        print(p)

        id = p.paperId
        #list seed paper in objects
        if id not in paper_lookup:
            paper_lookup.append(id)
            paper_objects[id] = p

        
        #skip if zero
        if len(p.citations) > 0:
            #add seed as parent
            paper_hierarchies[id] = []
            for c in p.citations:
                cid = c['paperId']
                #TODO: add error check if no paperId available
                paper_hierarchies[id].append(cid)

                # if paper not already retrieved
                if cid not in paper_lookup:
                    #...store in lookup...
                    paper_lookup.append(cid)
                    #...search for paper and store in objects
                    paper_objects[cid] = sch.get_paper(cid)
                    
                    if len(paper_lookup) >= paper_limit:
                        return paper_objects, paper_hierarchies, paper_lookup, paper_limit, True
                #skip if zero

        if len(p.references) > 0:
            for r in p.references:
                rid = r['paperId']

                #add own hierarchy if not present already
                if r not in paper_hierarchies.keys:
                    paper_hierarchies[r] = []

                paper_hierarchies[r].append(id)

                # if paper not already retrieved
                if rid not in paper_lookup:
                    #...store in lookup...
                    paper_lookup.append(rid)
                    #...search for paper and store in objects
                    paper_objects[rid] = sch.get_paper(rid)

                    if len(paper_lookup) >= paper_limit:
                        return paper_objects, paper_hierarchies, paper_lookup, paper_limit, True

    return paper_objects, paper_hierarchies, paper_lookup, paper_limit, False

# param:
# seeds are used to collect references and start the network
# number of iterations to collect references
def aggregate_network(paper_objects, paper_limit):
    seed_first_results = [sch.search_paper(x)[0] for x in paper_objects ]

    paper_objects = {}
    for x in seed_first_results: paper_objects[x.paperId] = sch.get_paper(x.paperId)

    paper_hierarchies = {}
    paper_lookup = []
    limit_reached = False

    while not limit_reached: 
        paper_objects, paper_hierarchies, paper_lookup, paper_limit, limit_reached = append_child_and_parents(paper_objects, paper_hierarchies, paper_lookup, paper_limit, limit_reached)

    return []




paper = sch.get_paper('10.1093/mind/lix.236.433')
#print(paper.references)
#print(paper.paperId)
kempe_paper = sch.search_paper("Maximizing the Spread of Influence through a Social Network")
#print(kempe_paper[0].title)
alessio_paper = sch.search_paper("Influence Maximization With Visual Analytics")
#print(alessio_paper[0].title)

saito_paper = sch.search_paper("Effective Visualization of Information Diffusion Process over Complex Networks")
#print(saito_paper[0].title)
#print(saito_paper[0].paperId)

paper = sch.get_paper(saito_paper[0].paperId)
#print(paper.citations)
#print(len(paper.references))

#seedset = ["Maximizing the Spread of Influence through a Social Network", "Influence Maximization With Visual Analytics", "Effective Visualization of Information Diffusion Process over Complex Networks"] 
seedset = ["Influence Maximization With Visual Analytics"] 

aggregate_network(seedset,10)

